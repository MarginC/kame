Portability guideline
KAME project
$Id: PORTABILITY,v 1.3 1999/08/12 15:29:27 itojun Exp $


Source code in "kame" directory will be shared among operating systems
and hardware platforms.  Here are several guidelines to be portable
across those possibilities.

- Do not break paren-match.
  Always try to keep paren-match correctly, regardless of #ifdef.
  The following is WRONG example:
	#if foo
		if (hoge) {
	#else
		if (hoge && hage) {
	#endif
			....
		}
  It should be written like follows:
	#if foo
		if (hoge)
	#else
		if (hoge && hage)
	#endif
		{
			....
		}

- Follow NetBSD KNF.
  They are the most strict guys about source code formatting.
  If you obey NetBSD KNF, other platforms are happy.

- Pointer can be 64bit (for example, on alpha).
  When taking integer from pointer, use u_long, or long.
  This is WRONG:
	void *p;
	/* alignment check */
	if ((1 & (int)p) == 0) {
		...
	}
  This is correct:
	void *p;
	/* alignment check */
	if ((1 & (u_long)p) == 0) {
		...
	}
  
- size_t can be 64bit.
  When doing printf(), cast size_t to u_long and print it as %lu.
	size_t siz;
	printf("%lu", (u_long)siz);

- tv.tv_sec is not typed as time_t.
  If you want time_t, explicitly copy the value.

- Packed structs must be used with care.
  Unaligned structure can cause problem on certain architectures.
  You'll need to copy the return value to aligned structure before accessing.

  Structure returned by SIOCGIFCONF falls into this category.

- 2nd arg to ioctl() must be u_long, not int, on non-FreeBSD2 platforms.

- If you define multi-statement #define, define that like:
	#define foobaa (x, y) \
	do { \
		/*something*/ \
	} while (0)
  Without this wrapper nasty mistakes can happen.

- BSDI3 make is a bit different from others:
  (1) MAN[0-9] does not respect .PATH
  (2) $> does not respect .PATH
  You'll need to implement necessary tricks on your own.
  The former one can be solved like below but is not a clean solution.
	.PATH:	${SRCDIR}
	_MAN5=	foo.5
	MAN5=	${_MAN5:s/^/${SRCDIR}\//g}

- BSDI3 /usr/bin/cc is gcc 1.42, and it does not support __FUNCTION__.
  If you need to use __FUNCTION__, you need to set CC to "gcc", or "shlicc2"
  explicitly.
  __FUNCTION__ macro is not included in ANSI standard, so it is best to
  avoid __FUNCTION__ for portability.

- For portability in networking code, look at kame/sys/net/net_osdep.h.
