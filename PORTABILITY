Portability guideline
KAME project
$Id: PORTABILITY,v 1.19 1999/11/06 15:28:00 itojun Exp $


Source code in the "kame" directory will be shared among operating systems
and hardware platforms.  Here are several guidelines to be portable
across those possibilities.

- Developers MUST compile the code on two or more platforms, before committing
  it to the repository (trivial changes or comment typos are okay).

- Do not break paren-match.
  Always try to keep paren-match correctly, regardless of #ifdef.
  The following is WRONG example:
	#if foo
		if (foo) {
	#else
		if (foo && bar) {
	#endif
			....
		}

		baa(this, that,
	#if foo
			something);
	#else
			something, anything);
	#endif
  It should be written like follows:
	#if foo
		if (foo)
	#else
		if (foo && bar)
	#endif
		{
			....
		}

	#ifdef foo
		baa(this, that, something);
	#else
		baa(this, that, something, anything);
	#endif

		/* latter part can also be like follows... */
		baa(this, that,
			something
	#ifndef foo
			, anything
	#endif
			);

  It is also advised to add extra comment to help paren match,
  if you need to write widow paren in string.  For example:
	printf("(");		/* ) */

- Follow NetBSD KNF.
  They are the most strict guys about source code formatting.
  If you obey NetBSD KNF, other platforms are happy.
  More information on KNF is available at:
	http://www.netbsd.org/Documentation/kernel/programming.html

- Pointer can be 64bit (for example, on alpha).
  When taking integer from pointer, use u_long, or long.
  This is WRONG:
	void *p;
	/* alignment check */
	if ((1 & (int)p) == 0) {
		...
	}
  This is correct (but actually is not future-proven - fail on 128bit arch):
	void *p;
	/* alignment check */
	if ((1 & (u_long)p) == 0) {
		...
	}
  
- size_t can be 64bit, and may not be of same size as int.
  When doing printf(), cast size_t to u_long and print it as %lu.
	size_t siz;
	printf("%lu", (u_long)siz);

- tv.tv_sec is not typed as time_t.
  If you want time_t, explicitly copy the value.

- Packed structs must be used with care.
  Unaligned structure can cause problem on certain architectures.
  You'll need to copy the return value to aligned structure before accessing.

  Structure returned by SIOCGIFCONF falls into this category.

- 2nd arg to ioctl() must be u_long, not int, on non-FreeBSD2 platforms.

- If you define multi-statement #define, define that like:
	#define foobar (x, y) \
	do { \
		/*something*/ \
	} while (0)
  Without this wrapper nasty mistakes can happen.

- Compiler options need to be configured differently into Makefile.
  For NetBSD and OpenBSD, CFLAGS and CPPFLAGS are defined separately:
	CPPFLAGS+=-I/usr/local/include
	CFLAGS+=-g
  For FreeBSD and BSDI, there's no distinction.
	CFLAGS+=-I/usr/local/include
	CFLAGS+=-g

- To refer objects and machine-generated source code, FreeBSD needs to use
  ${.OBJDIR}.  This is because because FreeBSD completely separates "obj" tree
  and "src" tree and has no symlink from ${.CURDIR}/obj to /usr/obj/foobar.
  On other platforms, ${.CURDIR}/obj should do.

- On manpage installation and shlib generation in Makefile.
  for BSDI3, you need to set MAN[0-9] in Makefile like below.  MANDIR must
  point to "catN" directory, not "manN", without "N":
	MANDIR=	/usr/local/v6/man/cat
	MAN5=	foo.0
	MAN8=	baz.0
	MLINKS=	foo.5 bar.5
  BSDI4 is much like the same as BSDI3.  The only exception is shlib
  generation.  NODYNAMIC=yes would prevent dynamic library from created:
	MANDIR=	/usr/local/v6/man/cat
	MAN5=	foo.0
	MAN8=	baz.0
	MLINKS=	foo.5 bar.5
	NODYNAMIC=yes	# if you do not want shlib, define it
  For NetBSD, you need to set MAN (not MAN[0-9]).  MANDIR needs to point to
  "man" directory right above "catN" or "manN" directory:
	MANDIR=	/usr/local/v6/man
	MAN=	foo.5 baz.8
	MLINKS=	foo.5 bar.5
	MKPIC=	# if you do not want shlib, make it empty
  For OpenBSD, you need to set MAN (not MAN[0-9]).  MANDIR needs to point to
  "catN" directory, without "N":
	MANDIR=	/usr/local/v6/man/cat
	MAN=	foo.5 baz.8
	MLINKS=	foo.5 bar.5
	NOPIC=	yes	# if you do not want shlib, define it
  For FreeBSD, you need to set MAN[0-9] like below.  MANDIR needs to point
  to "manN" directory, without "N":
	MANDIR=	/usr/local/v6/man/man
	MAN5=	foo.5
	MAN8=	baz.8
	MLINKS=	foo.5 bar.5
	# if you do not want shlib, do not define SHLIB_{MAJOR,MINOR}

- If you use yacc/lex, be aware that FreeBSD bsd.prog.mk behaves very
  strange with yacc's -o option (non-trivial .if statement is placed).
  You may need to add the following into Makefile for code sharing.
  The following fragment will force the build to generate y.tab.h, instead
  of foo.h.
	SRCS+=y.tab.h
	y.tab.h: foo.y
  Be sure to include y.tab.h, not foo.h, from *.l.

- BSDI3 /usr/bin/cc is gcc 1.42, and it does not support __FUNCTION__.
  If you need to use __FUNCTION__, you need to set CC to "gcc", or "shlicc2"
  explicitly.
  __FUNCTION__ macro is not included in the ANSI standard, so it is best to
  avoid __FUNCTION__, or make it optional, for portability.

- sys/queue.h are very different in each of *BSDs.  Most of macros found in
  FreeBSD3 are not available in other systems.  Simply avoid those, make sure
  your code compile on non-FreeBSD3 systems.
  Avoid xx_FOREACH(), which is only available in FreeBSD3.  Just use
	for (x = xx_FIRST(); x; x = xx_NEXT(x))
  and do not try to do #ifdef (FreeBSD3).  More #ifdef introduces more bugs.

- It is better to avoid insque() and rmque(), they are from old VAX days
  and some platform now tries to avoid these.

- To identify FreeBSD3, use the following:
	#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		this is freebsd3.
	#endif

- To identify BSDI4, use the following:
	#if defined(__bsdi__) && _BSDI_VERSION >= 199802
		this is bsdi4.
	#endif

- For portability in networking code, look at kame/sys/net/net_osdep.h.
